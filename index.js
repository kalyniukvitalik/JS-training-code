// Лічильник лайків
let heart = document.querySelector('.heart');
let likesNumber = document.querySelector('.likes-number');

heart.onclick = function () {
  if (heart.classList.contains('added')) {
    likesNumber.textContent--;
  } else {
    likesNumber.textContent++;
  }
  heart.classList.toggle('added');
};

// Додавання коментарів
let commentForm = document.querySelector('.comment-form');
let commentList = document.querySelector('.comment-list');
let commentField = document.querySelector('.comment-field');

commentForm.onsubmit = function (evt) {
  evt.preventDefault();

  let newComment = document.createElement('li');
  newComment.classList.add('user-comment');
  newComment.textContent = commentField.value;
  commentField.value = '';
  commentList.append(newComment);
  // Обнуляємо лічильник символів
  charCounter.textContent = 0;
};

// Обмеження на кількість символів у коментарях
commentField.oninput = function () {
  charCounter.textContent = commentField.value.length;

  if (commentField.value.length > 142) {
    commentForm.classList.add('warning');
    submitButton.disabled = true;
  } else {
    commentForm.classList.remove('warning');
    submitButton.disabled = false;
  }
};
////////////////////////////////////////////////////////////////////////////////////


/*
1. Каждая задача в списке — это элемент li. При отправке формы (переменная form) новая задача добавляется в конец списка (переменная list).
2. Текст задачи берётся из поля ввода (переменная input).
3. Если у переключателя приоритета (переменная priority) есть класс is-important, то новой задаче также добавляется класс is-important.
4. Бонус: после того, как задача добавится в список, поле ввода можно очистить. Но можно не очищать. Подходят оба варианта.
*/
let list = document.querySelector('.todo-list');
let input = document.querySelector('.todo-input');
let form = document.querySelector('.todo-form');
let priority = document.querySelector('.todo-priority');

priority.onclick = function () {
  priority.classList.toggle('is-important');
  if (priority.classList.contains('is-important')) {
    priority.textContent = 'Важная задача';
  } else {
    priority.textContent = 'Обычная задача';
  }
};

form.onsubmit = function (evt) {
  evt.preventDefault();
  
  let newTask = document.createElement('li');
  newTask.textContent = input.value;
  list.append(newTask);
  
  if (priority.classList.contains('is-important')) {
    newTask.classList.add('is-important')
  };
  
  form.value = '';
  
};
////////////////////////////////////////////////////////////////////////////////////


// Добавлення елемента прокрутки на сторінці із поверенням на задану точку і зникненняям після цього елемента прокрутки
let upButton = document.querySelector('.up-button');

window.onscroll = function () {
  if (window.pageYOffset > 200) {
    upButton.classList.add('shown');
  } else {
    upButton.classList.remove('shown'); }
};

upButton.onclick = function () {
  window.scrollTo(0, 0);
};

//Додавання класу кожному елементу із колекції
let articles = document.querySelectorAll('.news-block');
for (let article of articles) {
  article.classList.add('highlight')
}

//Фільтрація елементів на сайті 
let articles = document.querySelectorAll('.news-block');
let filter = document.querySelector('.filter');
// 1. Знаходимо кожен елемент із колекції за допомогою  'for...of'
// 2. Добавляємо фільтру оброблювач подій 'onchange'
// 3. За допомогою умовноої конструкції 'if...else' задаємо сценарії відображення. 'filter.value = !all' відповідає за відображення всіх категорій
filter.onchange = function () {
  for (let article of articles) {
    if (article.dataset.category !== filter.value && filter.value !== 'all') {
      article.classList.add('hidden');
    } else {
      article.classList.remove('hidden');
    }
  }
};

/*
1. У всех радиокнопок есть класс review.
2. Чтобы отслеживать переключение радиокнопок, нужно добавить обработчик событий onchange каждой радиокнопке.
3. У каждой радиокнопки есть атрибут data-evaluation. Если отзыв хороший, значение этого атрибута – 'good', а если плохой - 'bad'.
4. Кнопка отправки имеет класс submit-button. Если пользователь выбрал плохой отзыв, кнопку нужно заблокировать, а если хороший — разблокировать.
5. Чтобы показать сигнал об ошибке, элементу с классом error нужно добавить класс shown. Сигнал нужно показывать, если пользователь выбрал плохой отзыв. Если выбран хороший отзыв, сигнал об ошибке нужно спрятать.
*/
let radios = document.querySelectorAll('.review');
let btn = document.querySelector('.submit-button');
let error = document.querySelector('.error');

for (let radio of radios) {
    radio.onchange = function () {
  if (radio.dataset.evaluation === "bad") {
   btn.disabled = true; 
   error.classList.add('shown');
   } else {
    btn.disabled = false; 
   error.classList.remove('shown');
     }
   }
}
////////////////////////////////////////////////////////////////////////////////////


// Зміна кольору тексту на сторінці
let longread = document.querySelector('.longread'); // клас article, який охоплює весь текст, що піддається зміні
let colorSetting = document.querySelector('.color-setting'); // знаходимо випадаючий список
let backgroundSetting = document.querySelector('.background-setting'); // клас select, в який вставлені  всі  значення доступних фонових кольорів 

colorSetting.onchange = function () {
  longread.style.color = colorSetting.value
  } // добавляємо списку оброблювач подій 'onchange' і міняємона вибраний користувачем колір за допомогою 'value'

// 
let sizeSetting = document.querySelector('.size-setting'); // клас input, де вказані type="range" min="8" max="48" step="1" value="14", значення розміру за замовчуванням так кроки зміни 
let pixels = document.querySelector('.pixels'); // клас output, в якому вказаний розмір тексту за замовчуванням

sizeSetting.oninput = function () {
  pixels.textContent = sizeSetting.value; // Знаходимо поле і елемент для виведення значення. Додаємо полю обробник подій(таким  чиномвиводимо цифри зміни значення)
  longread.style.fontSize = sizeSetting.value + 'px'; // Схожим чиином змінюємо розмір тексту повзунком
  }; 

  backgroundSetting.onchange = function () {
    longread.style.backgroundColor = backgroundSetting.value}; // змінюємо фон із випадаючого списку


// Показуємо/ховаємо введений пароль. Замальовуємо полосу введення пароля у визначений колір
let password = document.querySelector('.password'); // знаходимо inpute type="password"
let showPassword = document.querySelector('.show-password'); // знаходимо input type="checkbox"
let securityBar = document.querySelector('.security-bar'); // знаходимо полосу, яка буде відображати кількість введених символів пароля

showPassword.onchange = function () { 
if (showPassword.checked) {
    password.type = 'text'; // дозволяє показувати пароль
    } else {
      password.type = 'password'; // стандартне значення для паролів. його повертаємо, коли сценарій false
    }
}; // спочатку чексбоксу задаємо змінювач подій у середині якого прописуємо сценарій

password.oninput = function () {
  let passLength = password.value.length; // у перемінну закладаємо значення кількості введених символів
  securityBar.style.width = passLength * 10 + '%'; // отримуємо ширину полоски
  if (passLength <= 5) {
    securityBar.style.backgroundColor = 'red';
  } else if (passLength > 5 && passLength < 10) {
    securityBar.style.backgroundColor = 'gold';
  } else {
    securityBar.style.backgroundColor = 'green';
    } // умовна конструкція, у якій прописані сценарії покраски полоски у певний колірм
};


/*
1. Все «пиксели» имеют класс pixel.
2. Выпадающий список с цветами имеет класс chosen-color.
3. «Ластик» — это чекбокс с классом eraser.
4. Когда на «пиксель» кликают, у него должен измениться цвет фона.
5. Если в момент клика ластик выключен, фон нажатого «пикселя» должен стать того цвета, который выбран в списке.
6. Если в момент клика ластик включён, фон нажатого «пикселя» должен стать белым — 'white'.
*/

let pixels = document.querySelectorAll('.pixel');
let chosenColor = document.querySelector('.chosen-color');
let eraser = document.querySelector('.eraser');

for (let pixel of pixels) {
  pixel.onclick = function () {
    if (!eraser.checked) {
    pixel.style.backgroundColor = chosenColor.value
    } else {
         pixel.style.backgroundColor = 'white'}
  }
}


/* Потрібно вдосконалити програму «Скільки гуляти?». Вхідні дані ті ж:

- рекомендований час прогулянки в змінної optimalTime;
- час, протягом якого Кекс гуляв, в змінної walkTime.
Але логіку потрібно змінити. Програма повинна показувати, скільки хвилин ще залишилося гуляти. Якщо прогулянка рівна або більша рекомендованому часу, то програма повинна показувати нуль.

Алгоритм рішення:
- заводимо нову змінну для зберігання часу, яке ще потрібно гуляти;
- перевіряємо, що час прогулянки більше або дорівнює рекомендованому часу;
- якщо так, то записуємо в нову змінну нуль;
- якщо немає, то віднімаємо з рекомендованого часу час прогулянки, а результат зберігаємо в нову змінну;
- виводимо красиве інформативне повідомлення.
*/
let optimalTime = 80;
let walkTime = 30;
let timeLeft;

if (walkTime >= optimalTime) {
  timeLeft = 0;
  console.log('Прогулянка закінчена');
} else {
  timeLeft = optimalTime - walkTime;
}
console.log('Гуляти ще потрібно ' +  timeLeft + ' хвилин.');


/* Нам потрібно об'єднати дві окремих перевірки в одну загальну. Проект можна почати, якщо:
- розробників досить
- і вони володіють технологіями
- і немає розробників у відпустці
- і немає розробників на лікарняному.
Реалізувати в коді цю логіку досить легко, адже заперечення можна комбінувати з іншими логічними операторами
*/
let enoughDevelopers = true;
let techAvailable = true;
let onVacation = false;
let onSickLeave = false;
// Для комбінування у даному випадку використовуємо !, так як  він  поверне нам всі умови переміннихяк  true. При зміні самої перемінної  із відпустками чи лікарняними на true  програма не виконається. Такі умови можна комбінувати
if (enoughDevelopers && techAvailable && !onVacation && !onSickLeave) {
  console.log('Проект можно выполнить');
} else {
 console.log('Проект нельзя выполнить'); 
}
////////////////////////////////////////////////////////////////////////////////////

// Програма 'Шлях до магазину'
/*
Напиши програму, яка визначить найближче працююче місце з молоком.
Час записано в годиннику в змінну time.
Молокозавод знаходиться найближче. Він починає працювати в 8, а закривається в 19. Перерва на обід з 13 до 14.
Далі знаходиться магазин. Він працює з 9 до 17. Перерва на обід з 14 до 15.
Далі за всіх знаходиться ринок. Він працює з 7 до 20 без перерв.
В інший час всі місця закриті і можна нікуди не ходити.
Обчисли, куди треба піти за молоком і запиши значення true в одну з змінних: goToDairy (молокозавод), goToStore (магазин), goToMarket (ринок).
*/
let time = 15;
let goToDairy = false;
let goToStore = false;
let goToMarket = false;

if (time >= 8 && time < 13 || time >= 14 && time < 19) {
  goToDairy = true;
} else if (time >= 9 && time < 14 || time >= 15 && time < 17) {
    goToStore = true;
  } else if (time >= 7 && time < 20) {
      goToMarket = true; 
        } else {
          console.log(`Все закрито`);
          }
////////////////////////////////////////////////////////////////////////////////////

/* Програма: «Час прогулянки»
Технічне завдання
Тривалість прогулянки залежить від декількох умов.

Якщо йде дощ, гуляти я не ходжу. У цьому випадку тривалість прогулянки дорівнює 0. А ось якщо дощу немає, все залежить від температури на вулиці:
По-перше, якщо температура від 10 ° C (включно) до 15 ° C (не включаючи це значення), я гуляю 30 хвилин.
По-друге, якщо температура від 15 ° C (включно) до 25 ° C (не включаючи значення), я гуляю 40 хвилин.
По-третє, при температурі від 25 ° C (включно) до 35 ° C (включно), я гуляю 20 хвилин.
В інших випадках я нікуди не виходжу: або дуже холодно, або дуже жарко.

Результат програми - час прогулянки. Його необхідно записати в змінну minutes.
*/
let temperature = 20;
let isRaining = true;
let minutes = 0;

if (isRaining) {
  minutes;
  console.log('Падає дощ');
  } else if ( temperature >= 10 && temperature < 15) {
  minutes = 30;   
  console.log('Я гуляю ' + minutes +  ' хвилин');
  } else if ( temperature >= 15 && temperature < 25) {
  minutes = 40;
  console.log('Я гуляю ' + minutes +  ' хвилин');
  } else if ( temperature >= 25 && temperature <= 35) {
  minutes = 20;
  console.log('Я гуляю ' + minutes +  ' хвилин');
  } else {
    minutes;
    console.log('Я  залишаюсь вдома');
  }
////////////////////////////////////////////////////////////////////////////////////

/* Програма: «Час прогулянки 2.0»
Технічне завдання
Тривалість прогулянки залежить від декількох умов.
По-перше, якщо йде дощ, прогулянка не може відбутися. У цьому випадку тривалість прогулянки повинна дорівнювати 0.
По-друге, якщо температура занадто низька (нижче 0 ° C) або надто висока (вище 35 ° C), прогулянка теж не відбудеться.
По-третє, ідеальна температура для прогулянки - 20 ° C. В цьому випадку прогулянка триває 20 хвилин.
В інших випадках тривалість прогулянки зменшується на хвилину з кожним градусом відхилення від ідеальної температури: при 19 ° C або 21 ° C тривалість складе 19 хвилин, при 18 ° C або 22 ° C - 18 хвилин і так далі.
*/
// Варіант 1
let temperature = 20;
let itsRaining = false;
let minutes;

if (itsRaining || temperature > 35 || temperature < 0) {
  minutes = 0;
  } else if (temperature > 20) {
    minutes = 20 - (temperature - 20)
  } else if (temperature < 20) {
    minutes = 20 - (20 - temperature)
  } else {
    minutes == 20}

// Варіант 2
let temperature = 20;
let itsRaining = false;
let minutes;

if (itsRaining || temperature > 35 || temperature < 0) {
  minutes = 0;
  } else if (temperature == 20) {
    minutes = 20;
    } else {
      minutes = 20 - Math.abs(temperature - 20) //  метод Math.abs повертає абсолютне значення числа, тобто іншими словами - якщо число невід'ємне, то його і повертає, а якщо негативне - відкидає знак "мінус"
    }
  


// Потрібно напечатати певну кількість сторінок. Робимо це за допомогою циклу for
let totalPages = 5;

for (let page = 1; page <= totalPages; page = page + 1) { // цикл починаємо не з 0, а з 1(перша сторінка) і закінчуємо <=, так як вказана остання сторінка теж має печататись
  // тіло циклу. тут викликатиметься функція, яка печататиме;
}

// друк за допомогою циклу у зворотньому порядку
let totalPages = 5;
// тут нам потрібно вказати, що початкова сторінка початку друку рівна загальній кількості сторінок (page=totalPages), цикл повинен виконуватись поки змінна більше 0 і після кожної ітерації зменшуватись на 1
for (let page = totalPages; page > 0; page = page--) {
  // тіло циклу. тут викликатиметься функція, яка печататиме;
}
////////////////////////////////////////////////////////////////////////////////////

// Режими друку/копіювання сторінок
let mode = 'alternate'; // Режим работы драйвера печати
let pageNumber = 5; // Номер копируемой страницы
let copyCount = 7; // Количество копий
let totalPages = 6; // Всего страниц в документе
let startPage = 2; // Стартовая страница

if (mode === 'pageCopy') {
  for (let copies = 1; copies <= copyCount; copies++) {
    keks.print(pageNumber);
  }
} //  Копіювання

if (mode === 'document') {
  for (let page = 1; page <= totalPages; page++) {
    keks.print(page);
  }
} // Друк  звичайни

if (mode === 'reverse') {
  for (let reversePage = totalPages; reversePage >= 1; reversePage--) {
    keks.print(reversePage);
  }
} //  Реверсний друк

if (mode === 'alternate') {
  for (let alternatePage = startPage; alternatePage <= totalPages; alternatePage += 2) {
    keks.print(alternatePage);
  }
} // Друк парних/непарних стоорінок (залежить від значення в перемінній startPage)

////////////////////////////////////////////////////////////////////////////////////
/*
Накопичення в циклі 
Якщо на кожній ітерації нам потрібно отримувати нове, збільшене, число, треба завести перед циклом ще одну змінну, яка і буде зберігати суму.
Тепер на кожній ітерації ми додаємо 2 до змінної sum, накопичуючи її значення. Перемінна sum оголошена зовні циклу (а не всередині тіла циклу, що важливо), тому її значення не скидається при попаданні в тіло циклу, а збільшується на 2.

Така операція називається накопиченням значення в циклі.
*/
let sum = 0;

for (let i = 1; i <= 5; i++) {
  sum += 2;
  console.log(sum);
}

let sum = 0;

for (let i = 1; i <= 10; i++) {
  sum += i;
  console.log('i: ' + i);
  console.log('sum: ' + sum);
  }
////////////////////////////////////////////////////////////////////////////////////

// Сума чисел. Технічне завдання
/*
Напишіть універсальну програму, яка обчислює суму чисел від 1 до n.
Число, до якого потрібно складати числа (включно), зазначено в перемінній lastNumber.
Знайдіть суму всіх чисел і збережіть результат в перемінну sum.
*/
// Варінат 1. Цикл for
let lastNumber = 10;
let sum = 0;

for (let firstNumber = 1; firstNumber <= lastNumber; firstNumber++) {
    sum += firstNumber;
    console.log(sum)
}
//  Варіант 2. Цикл do...while
let lastNumber = 10;
let sum = 0;
let firstNumber = 1;

do {
  sum += firstNumber;
  firstNumber++;
  } while (firstNumber <= lastNumber)
  ////////////////////////////////////////////////////////////////////////////////////

// Добуток парних чисел. Технічне завдання
/*
Крім суми чисел від 1 до n можна ще знайти їх добуток. Але в цей раз завдання ускладнилося - потрібно знайти твір не всіх чисел з послідовності, а тільки парних.
Напишіть універсальну програму, яка знаходить добуток всіх парних чисел з послідовності від 1 до n.
Число, до якого йде послідовність (включно), записано в перемінну lastNumber
Знайдіть твір всіх чисел і збережіть результат в перемінну multiplicationResult.
*/
let lastNumber = 5;
let multiplicationResult = 1;

for (let firstNumber = 1; firstNumber <= lastNumber; firstNumber++) { 
  if (firstNumber % 2 === 0) { 
    multiplicationResult *= firstNumber;
    }
}


// Перевірка у циклах
/* Можна писати цикли всередині умов, але можна і навпаки. Якщо додати умову всередину циклу, то воно буде перевірятися на кожній ітерації.
Наприклад, можна перевіряти значення лічильника, і якщо воно більше двох, додавати до суми 3, а не 2.
*/
 let sum = 0;

for (let i = 1; i <= 5; i++) {
  if (i > 2) {
    sum += 3;
  } else {
    sum += 2;
  }
  console.log(sum);
}

// Пошук парного числа. Технічне завдання
/* Перевірки в циклах дуже зручні. Вони дозволяють робити перевірки на кожній ітерації циклу.
Наприклад, можемо перевірити парне чи непанрне число i. І якщо число парне, будемо додавати до суми 2, а якщо число непарне, будемо додавати 1.
Як перевірити, що число парне? Тут може допомогти оператор %. Він називається залишок від ділення і, як зрозуміло з назви, повертає залишок від ділення.
Як це допоможе у визначенні парного або непарного числа? Парне число ділиться на 2 без залишку. Тому, якщо розподіл i% 2 повертає 0 - число парне, інакше число непарне.
Напишемо перевірку з використанням % в нашому циклі.
*/
let sum = 0;

for (let i = 1; i <= 10; i++) {
  console.log('i: ' + i);
 if ( i % 2  === 0) {
  sum += 2;
  console.log('чётное число');
 } else {
   sum += 1;
   console.log('нечётное число');  
   }
  console.log('sum: ' + sum);
}
 ////////////////////////////////////////////////////////////////////////////////////

 // Пошук ділителів числа. Технічне завдання
 /*
 Ділитель - число, на яке інше число ділиться без залишку.
 Напишіть програму, яка знаходить поділені на число числа, крім одиниці і самого числа.
 Число, ділителі якого потрібно знайти, записано в перемінну number.
 Виводьте ділителі в консоль послідовно, один за одним.
 */
// Варіант 1. Цикл for
let number = 15;

for (let i = 1; i <= number; i++) {
    if (number % i === 0 && i !== number && i !== 1) {
     console.log(i); 
    }
  }
// Варіант 2. Цікл do...while
let number = 15;
let i = 0;
  
  do {
    i++;
    if (number % i === 0 && i !== number && i !== 1){
      console.log(i);
    }
  } while (i <= number) 
////////////////////////////////////////////////////////////////////////////////////


// FizzBuzz
/* Технічне завдання
Програма повинна аналізувати числа.
Якщо число ділиться на 3, результат роботи програми - рядок 'Fizz'.
Якщо число ділиться на 5 - рядок 'Buzz'.
Якщо число одночасно ділиться на 3 і на 5 - результат 'FizzBuzz'.
В інших випадках результат роботи програми - початкове число.
Число записано в змінну number.
Результат роботи програми записуйте в перемінну taskResult.
*/
let number = 15;
let taskResult;

for (let i = 0; i <= number; i++) {
  if (i % 3 === 0 && i % 5 === 0) {
    taskResult = 'FizzBuzz';
} else if (i % 3 === 0) {
  taskResult = 'Fizz';
} else if (i % 5 === 0) {
  taskResult = 'Buzz';
  } else {
    taskResult = number;
  }
}
 ////////////////////////////////////////////////////////////////////////////////////

/*
Повернемося до принтера. Ми написали програму, яка вміє друкувати сторінки, але випустили з уваги одну деталь - на друк кожної сторінки витрачається фарба. У нашому принтері на одну сторінку «йде» 70 мг порошку з фарбою. Добре б стежити за витратою тонера і знати, скільки витрачається на друк одного документа.
Для вирішення цього завдання будемо використовувати накопичення значень в циклі. Заведемо зовнішню змінну, куди будемо додавати 70 мг (витрата на одну сторінку) при друку кожної сторінки документа. Але спочатку цю змінну потрібно назвати.
Порахуємо витрати тонера на друк всіх сторінок. Вважати будемо в режимі друку звичайного документа.
*/
let totalPages = 6; // Загалом сторінок у документі
let consumptionTotal = 0; // Загальні витрати на всі сторінки
let consumptionPerPage = 70; // Витрати на одну сторінку

for (let page = 1; page <= totalPages; page++) {
  keks.print(page);
  consumptionTotal += consumptionPerPage;
  console.log(consumptionTotal)
}

/*
Економічний друк
Нашим принтером часто користуються студенти, а для студентів дуже важлива економія. Економія на всьому. Наші аналітики з'ясували, що викладачі зазвичай читають не більше перших трьох сторінок усіх звітів, курсовиків та інших студентських документів. З цього таємного знання народилася ідея режиму друку для студентів: перші три сторінки друкуємо як зазвичай, а на що залишилися економимо тонер в усі тяжкі (тобто використовуємо в ДВА рази менше тонера)!
Тепер нам потрібно не просто збільшувати значення consumptionTotal при кожній ітерації на 70, але і перевіряти в якому режимі друку ми знаходимося (економічному або звичайному) і яку за рахунком сторінку документа друкуємо. Тут стануть в нагоді умови.
Використовуємо умова в циклі, щоб перевірити режим друку. Якщо режим економічний, будемо відловлювати сторінки з номером більше 3 і друкувати їх з меншою витратою фарби. Половину витрат будемо записувати як consumptionPerPage * 0.5.
*/

let totalPages = 6; // Загалом сторінок у документі
let consumptionTotal = 0; // Загальні витрати на всі сторінки
let consumptionPerPage = 70; // Витрати на одну сторінку
let economyMode = false; // Економ режим

for (let page = 1; page <= totalPages; page++) {
  keks.print(page);

  if (economyMode === true && page > 3) {
    consumptionTotal += consumptionPerPage * 0.5;
    } // умова виглядає наступним чином. Якщо включений екрном режим і сторінка друку більше третьої, то збільшуємо загальні витрати на одну сторінку на суму витрат на одну сторінку, яке ділимо на 2 (0.5)

  consumptionTotal += consumptionPerPage;
  console.log(consumptionTotal);
}
/*
Виходить, якщо включений економічний режим і номер сторінки більше трьох, ми витрачаємо половину фарби від звичайного режиму на одну сторінку. А потім, неважливо, спрацює умова чи ні, ми обов'язково збільшуємо витрати ще 
*/
let totalPages = 6; // Всего страниц в документе

let consumptionTotal = 0; // Общий расход тонера
let consumptionPerPage = 70; // Расход краски на одну страницу
let economyMode = true;

for (let page = 1; page <= totalPages; page++) {
  keks.print(page);

  if (economyMode && page > 3) {
    consumptionTotal += consumptionPerPage * 0.5;
  } else { // Щоб уникнути додавання декількох умов, додамо гілку else до умови і перенесемо туди рядок consumptionTotal + = consumptionPerPage;. 
    consumptionTotal += consumptionPerPage;
}

/* Програма для підрахунку кількості випитого протеїну. Технічне завдання.
Програма повинна рахувати скільки протеїну я повинен випити за весь тренувальний період.
У парні дні я п'ю 200 грам. У непарні 100 грам.
Кількість днів зберігається в змінної days, кількість протеїну для прийому в парний день - у змінній evenDayAmount, протеїн в непарний день - у змінній oddDayAmount, а результат необхідно записати в змінну total, яка вже задана.
*/
let days = 9; // Днів у періоді
let evenDayAmount = 200; // Кількість протеїну у парні дні
let oddDayAmount = 100; // Кількість протеїну у непарні дні
let total = 0; // Загальна кількість протеїну


for (let day = 1; day <= days; day++) {
  if (day % 2 === 0) {
    total += evenDayAmount;
    console.log("Сьогодні п`єш 200 протеїну");
} else {
  total += oddDayAmount;
  console.log("Сьогодні п`єш 100 протеїну");
  }
}
 ////////////////////////////////////////////////////////////////////////////////////

 /* Запаси протеїну. Технічне завдання
 /* Технічне завдання
Програма повинна рахувати кількість протеїну необхідне на період.
По-перше, розрахунок завжди починається з понеділка. Це перший день.
По-друге, я приймаю протеїн кожен третій день:
1 день, субота - немає,
2 день, неділя - немає,
3 день, середа - так,
4 день, субота - немає,
5 день, п'ятниця - немає,
6 день, субота - так,
7 день, неділя - немає,
8 день, субота - немає,
9 день, неділя - так
і так далі.
По-третє, відомо, скільки протеїну я з'їдаю в будні і скільки у вихідні дні.
По-четверте, період задається цілим числом, від одного до нескінченності (хоча плани далі ніж на місяць я зазвичай не будую).
Програма повинна повертати загальна кількість протеїну за період, записане в перемінну total.
*/
// Варіант 1
let days = 9; // Днів в періоді
let period = 3; // Як часто я їм протеїн (раз в три дні)
let workDayAmount = 200; // Кількість протеїну в будні
let weekendAmount = 100; // Кількість протеїну в вихідні
let total = 0;

for (let day = 1; day <= days; day++) {
    if (day % period ===  0 && (day % 7 === 0 || day % 7 === 6)) {
    total += weekendAmount;
    } else  if (day % period === 0) {
      total += workDayAmount;
    }
  } 
// Варіант 2
let days = 9; // Днів в періоді
let period = 3; // Як часто я їм протеїн (раз в три дні)
let workDayAmount = 200; // Кількість протеїну в будні
let weekendAmount = 100; // Кількість протеїну в вихідні
let total = 0;
let dayOfWeek = 1; // День тижня

for (let i = 1; i <= days; i ++) {
if (i % period == 0) {
  if (dayOfWeek == 6 || dayOfWeek == 7) {
    total += weekendAmount;
  } else {
    total += workDayAmount;
    }
  }
  dayOfWeek += 1; // Збільшуємо лічильник дня тижня
  if (dayOfWeek> 7) {
      dayOfWeek = 1;
  } // Обнуляємо лічильник на початок нового тижня
}
 ////////////////////////////////////////////////////////////////////////////////////

// Геометрична прогресія. Технічне завдання
/*
Геометрична прогресія - послідовність чисел, де кожне наступне число - це попереднє, збільшене на множник.
Наприклад, потрібно написати геометричну прогресію з п'яти чисел, починаючи з одиниці. Множник - двійка. Тоді числа будуть такими: 1, 2, 4, 8, 16. Тут кожне наступне число - твір попереднього числа і множника (двійки).
Напишіть програму, яка послідовно виводить в консоль числа в геометричній прогресії.
Стартове значення, з якого має розпочатися послідовність, записано в змінну startNumber.
Множник записаний в змінну multiplier.
Кількість чисел записано в змінну quantity.
*/
// Варінат 1. Із циклом While
let startNumber = 1;
let multiplier = 4;
let quantity = 7;
let startPoint = 0;

while (startPoint < quantity) {
  console.log(startNumber);
  startNumber *= multiplier;
  startPoint++;
}
// Варінат 2. Із циклом For
let startNumber = 1;
let multiplier = 4;
let quantity = 7;

for (let startPoint = 0; startPoint < quantity; startPoint++) {
  console.log(startNumber);
  startNumber *= multiplier;
}
////////////////////////////////////////////////////////////////////////////////////

// Скільки цифр у числі. Технічне завдання
/*
Напиши програму, яка визначає скільки цифр в одному числі.
Саме число записано в змінну number.
Знайди кількість цифр в цьому числі і запиши результат в змінну quantity.
*/
let number = 123;
let quantity = 0;

do {
  quantity++;
  number /= 10;
  console.log(quantity);
} while (1 <= number)
////////////////////////////////////////////////////////////////////////////////////

 //  Програма 'Дартс-машина'
/*
 Правила роботи:
- кожна гра починається з 0 очок.
- щоб виграти, потрібно набрати 100 і більше очок.
- в процесі гри можна зробити не більше трьох промахів, інакше програєш.
- в процесі написання програми ми розберемо використання циклу while, а також операторів break і continue.
Ми створимо цикл, усередині якого буде відбуватися підрахунок очок, використовуючи конструкцію while. Усередині умови виходу нам потрібно кожен раз перевіряти, набрав гравець необхідну кількість очок.
На першому кроці ми змінимо умову так, щоб гра закінчувалася при досягненні ста очок.
*/
let score = 0;
let total = 0;
let victoryPoints = 100;

while (total < victoryPoints) {
  total += score;
  console.log(score);
}
/*
Давайте додамо трохи інтриги і будемо переривати цикл, як тільки ми промахнулися три рази.
Для цього нам знадобиться перемінна, яка буде вважати промахи, назвемо її misses. Кожен раз, коли гравець промахується, ми будемо збільшувати цю змінну на одиницю.
Команда keks.getScore повертає -1, якщо гравець не влучив. Тому всередині циклу потрібно додати перевірку, що результат поточного кидка менше нуля. І якщо перевірка спрацьовує, то пишемо в консоль про промах і збільшуємо на одиницю лічильник промахів.
Дії всередині циклу повинні будуть виглядати так:
Отримуємо результат кидка.
Перевіряємо, що результат кидка менше нуля. Якщо це так, то переходимо до кроку три, інакше до кроку чотири.
Пишемо в консоль про промах і збільшуємо лічильник промахів на одиницю.
Збільшуємо загальний результат total і виводимо результат кидка в консоль.
*/
let score = 0;
let total = 0;
let victoryPoints = 100;
let misses = 0;

while (total < victoryPoints) {
  if (misses  >= 3) {
    break // добавляємо даний оператор на початку цикла для перевірки кількості промахів. Якщо  їх три (тобто відповідає умові)- виходимо із циклу. Оператор break використовується для переревання циклу чи чи переходу до наступного виразу/дії.
    }

  score = keks.getScore();
  if (score < 0) {
    console.log('Промах!');
    misses += 1;
    } else { 
      total += score;
      console.log('Результат кидка: ' + score);
  }
}

if (total >= victoryPoints) {
  console.log('Перемога! Очок: ' + total + ', промахів: ' + misses);
  } else {
    console.log('Поразка. Очок: ' + total + ', промахів: ' + misses);
  }  // Перевіряємо, чи з'явився переможець. Якщо після циклу кількість очок більше або дорівнює ста(умова самоїгри), то це перемога. Інакше це поразка.

// Програма для  підрахунку тренувальних днів. Технічне завдання
/*
Хочу дізнатися, скільки ще днів залишилося займатися, щоб досягти потрібної ваги.
Вхідні дані: вага на початку дієти і вага в кінці.
Логіка роботи: поки я тренуюся і сиджу на дієті, то втрачаю 5% своєї маси в день.
Просто порахуй, скільки днів знадобиться провести в такому режимі і запиши кількість в змінну days.
Звичайно, в цій програмі зручніше використовувати while, так як кількість ітерацій заздалегідь невідомо.
Вага втрачається кожен день по 5%. При цьому вага оновлюється щодня. Наприклад, якщо спочатку це 5000 грам, то на наступний день - 4750 грам. А другого дня вже 5% від нового ваги, тобто від 4750 грам. Врахуйте це при розрахунках.
*/
// Варіант 1
let initialWeight = 6000; // Вихідна вага
let targetWeight = 5000; // Бажана вага
let days = 0; // Кількість днів тренувань для досягення бажаної ваги

while(initialWeight > targetWeight) {
  days++;
  initialWeight -= initialWeight * 0.05; // Таким чином ми при кожній новій ітерації циклу  перезаписуємо перемінну initialWeight із актуальним показником
}
console.log(days)
// Варіант 2
let initialWeight = 6000; // Вихідна вага
let targetWeight = 5000; // Бажана вага
let days = 0; // Кількість днів тренувань для досягення бажаної ваги 

while(initialWeight > targetWeight) {
  let currentDayWeight = initialWeight * 0.05; // Створюємо перемінну, яка буде містити актуальну вагу і змінюватись при кожній ітерації  циклу
  initialWeight -= currentDayWeight;
  days++;
}
console.log(days)
////////////////////////////////////////////////////////////////////////////////////

/* Розрахунок КБЖУ. Технічне завдання
Потрібно розрахувати КБЖУ(калорії, білки, жири, вуглеводи). Для цього в першу чергу треба порахувати рівень метаболізму: 88.362 + (13.397 * вага в кг) + (4.799 * довжина в см) - (5.677 * вік в роках).
Вага в кілограмах зберігається в змінної weight, довжина в сантиметрах записана в змінну length, вік в роках знаходиться у змінній age.
Норма калорій розраховується так: рівень метаболізму * коефіцієнт рухової активності. Коефіцієнт записаний в змінну activityRate. Порахуй норму калорій і запиши результат в змінну calorieRate.
Калорійність складається з білків, жирів і вуглеводів. У дієті білки повинні складати 40% від всієї калорійності. Знайди їх і запиши в змінну proteins.
Жири запиши в змінну fats, вони повинні складати 25% від всіх калорій.
А вуглеводи запиши в змінну carbohydrates, вони становлять 35%.
Кожне із значень (калорії, білки, жири і вуглеводи) округли за допомогою Math.round.
*/
let weight = 65;
let length = 170;
let age = 25;
let activityRate = 2.725;
let metabolismLevel = 88.362 + (13.397 * weight) + (4.799 * length) - (5.677 * age);
let calorieRate = Math.round(metabolismLevel * activityRate);
let proteins = Math.round((calorieRate / 100) * 40);
let fats = Math.round((calorieRate / 100) * 25);
let carbohydrates = Math.round((calorieRate / 100) * 35);
////////////////////////////////////////////////////////////////////////////////////

// Розраховуємо знижку покупки. Технічне завдання
/*
Напиши програму, яка буде розраховувати суму покупки з урахуванням знижки.
Вартість записана в перемінній price.
Якщо вартість покупки від 1000 (включно) до 3000 (без урахування цього значення), знижка складає 5%.
Якщо вартість покупки від 3000 (включно) до 5000 (без урахування цього значення), знижка 10%.
Якщо вартість покупки від 5000 (включно) і вище, знижка 15%.
В інших випадках знижки для покупців немає.
Обчислюй вартість з урахуванням знижки та записуй результат у перемінну discountedPrice.
*/
let price = 4000;
let discountedPrice;

if (price >= 1000 && price < 3000) {
  discountedPrice = price - (price * 0.05);
} else if (price >= 1000 && price < 5000) {
    discountedPrice = price - (price * 0.1);
  } else if (price >= 5000) {
      discountedPrice = price - (price * 0.15);
    } else {
      discountedPrice = price;
      }
////////////////////////////////////////////////////////////////////////////////////

// Підраховуємо кількість відвідувачів блогу
let expectedUsers = 1000; // Мінімальна очікувана кількість відвідувачів
let usersByDay = [817, 1370, 752, 1247, 681, 1120, 915, 875, 1341, 757, 610, 812, 1170, 769, 1261, 845, 1289, 515, 1247, 845, 1311, 741, 1239, 812, 638, 877, 1242, 1 159, 1372]; // Масив із даними про відвідування

// Малюємо графік відвідуваності
keks.plot (usersByDay, expectedUsers); // Стороння програма

// Підсумовуємо відвідуваність
let totalUsers = 0; // Загальна кількість відвідувачів
let minUsers = expectedUsers - 100; // Поганий день - це відвідуваність на 100 осбі менше від запланованої. Це фільтр, який можна налаштовувати
let badDays = []; // Пустий масив, у який записуватимемо невдалі дні

for (let i = 0; i <= usersByDay.length - 1; i ++) {
  totalUsers + = usersByDay [i];
  if (usersByDay[i] < minUsers) { // тут показуємо у які дні була просадка по відвідуваннях
    badDays[i] = expectedUsers - usersByDay[i]; // Якщо перевірку на поганий день вірна, то записуємо, скільки людей від  запланованої кількості ми не дорахувались
      } else {  
      badDays[i] = 0; // Якщо перевірка не пройдена, то нічого не записуємо
  }
}

// Розраховуємо середнє значення відвідуваності
let averageUsers = totalUsers / usersByDay.length;
console.log ( 'Середня відвідуваність:' + averageUsers);

if (averageUsers> expectedUsers) {
  console.log ( 'Відвідуваність чудова. Продовжуй в тому ж дусі!');
} else {
  console.log ( 'Відвідуваність так собі. Потрібно докласти зусиль!');
}
////////////////////////////////////////////////////////////////////////////////////

/* Дешифрувальник.Технічне завдання
Я навчився шифрувати і мені потрібна програма розшифровки.
Є масив symbols, в якому зберігається алфавіт (букви і інші символи).
Є масив encodedSymbols, в якому зберігається зашифроване повідомлення. Кожен елемент цього масиву - це індекс символу з масиву symbols.
Програма дешифровки повинна переводити елементи з масиву з кодуванням (encodedSymbols) в символи з масиву алфавіту (symbols) і склеювати з них розшифровану рядок. Цей рядок запиши в змінну decodedMessage.
*/
// Алфавіт
let symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];
// Закодоване повідомлення
let encodedSymbols = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];
// Розкодоване повідомлення
let decodedMessage = '';
// Варіант 1
for (let i = 0; i < encodedSymbols.length; i++) {
  let message;
  message = encodedSymbols[i];
  decodedMessage  += symbols[message]
}
// Варіант 2
for (let i = 0; i <= encodedSymbols.length - 1; i++) {
  decodedMessage  += symbols[encodedSymbols[i]]
}
////////////////////////////////////////////////////////////////////////////////////

// Міняємо цифри у масиві місцями
let usersByDay = [4, 1, 2, 3];
console.log(usersByDay);

// У swap зберігаєится 4
let swap = usersByDay[0];

// зараз масив виглядає так [1, 1, 2, 3]
usersByDay[0] =  usersByDay[1];

usersByDay[1] = swap;
// результат [1, 4, 2, 3]
////////////////////////////////////////////////////////////////////////////////////

// Шукаємо мінімальний елемент
/*
Наступний крок на шляху до сортування - пошук мінімального елемента. І цей елемент ми будемо шукати не в усьому масиві, а в зазначеній його частині.
Для цього заведемо перемінну currentIndex. Вона буде керувати початковим значенням перемінної циклу. Зверніть увагу, що перемінна циклу в цей раз буде називатися j.
Чому початкове значення змінної циклу задано як currentIndex + 1? Це потрібно, щоб шукати мінімальне значення після елемента з позицією currentIndex.
Як знайти мінімальний елемент, розташований після першого?
-Додамо перемінну minValue для зберігання мінімального значення.
-Припустимо, що перший елемент і є мінімальний. Тому до циклу збережемо в minValue значення першого елемента.
-На кожній ітерації циклу порівнюємо поточний елемент зі значенням minValue.
-Якщо поточний елемент менше minValue, то записуємо його в minValue.
-Якщо перший елемент і був мінімальний, то в циклі значення minValue не зміниться, якщо ж після першого елемента були елементи з меншим значенням, то це значення запишеться в minValue в циклі.
*/
let usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

let currentIndex = 0;
let minValue = usersByDay[currentIndex];

for (let j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j]  < minValue) {
    minValue = usersByDay[j];
    console.log('Новий мінімальний елемент: ' + minValue)
    }
}
console.log('Мінімальний елемент: ' + minValue)

// Починаємо сортування. Технічне завдання
/*
Тепер давайте не просто знаходити мінімальне значення після першого елемента, а записувати це значення на місце першого елемента. Для цього потрібно небагато доповнити алгоритм:
-Додамо перемінну minValue для зберігання мінімального значення.
-Припустимо, що перший елемент і є мінімальний. Тому до циклу збережемо в minValue значення першого елемента.
-На кожній ітерації циклу порівнюємо поточний елемент зі значенням minValue.
Якщо поточний елемент менше minValue, то записуємо його в minValue, а потім міняємо місцями значення першого елемента і поточного.
*/
let usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

let currentIndex = 0; // Якщо потрібно пересортувати не тільки пеший мінімальний  об'єкт, а і решта, то даний код копіюється і на даній позиції  currentIndex міняється на наступні по порядку індекси
let minValue = usersByDay[currentIndex];

for (let j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    let swap = usersByDay[currentIndex]; // Усередині умови після перемінної minValue потрібно зберегти значення usersByDay[currentIndex] в перемінну swap
    usersByDay[currentIndex] = minValue; // У usersByDay [currentIndex] потрібнозаписати мінімальне значення.
    usersByDay[j] = swap; // Тут в usersByDay[j] значення перемінної swap
    console.log('Міняю місцями ' + swap + ' и ' + minValue);
    console.log('Масив зараз: ' + usersByDay);
  }
}
console.log('Мфнімальний елемент: ' + minValue);
// Дії, яківідбувались при виконанні такого коду
// Міняю місцями 4 та 2
// Масив зараз: 2,4,1,3
// Міняю місцями 2 і 1
// Масив зараз: 1,4,2,3
// Мінімальний елемент: 1


// Завершуємо сортування. Рефакторинг коду для сортування багатьох чисел
/*
Для того, щоб сортування із прикладу вище не перетворилося на копіювання коду із зміною початкового індексу, можна взяти шматок коду з циклом, який шукає і підставляє на вказане місце мінімальне значення, і обернути його в інший цикл. І в цьому верхньому, «батьківському», циклі нарощувати змінну currentIndex.
Потрібно врахувати, що currentIndex повинна змінюватися не від нуля до довжини масиву, а від нуля до довжини масиву, зменшеної на одиницю. У минуломк завданні, завершилось сортування для масиву, дійшовши до передостаннього елемента (адже останній елемент автоматично виявився максимальним).
*/
let usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

for (let currentIndex = 0; currentIndex <= usersByDay.length - 2; currentIndex++) { // Даний цикл збільшує перемінну currentIndex з нуля до usersByDay.length - 2 включно. Значення currentIndex збільшується на одиницю після кожної ітерації

  let minValue = usersByDay[currentIndex];

  for (let j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      let swap = usersByDay[currentIndex];
      usersByDay[currentIndex] = minValue;
      usersByDay[j] = swap;
      console.log('Меняю местами ' + swap + ' и ' + minValue);
      console.log('Массив сейчас: ' + usersByDay);
     }
    }
  console.log('На позиции ' + currentIndex + ' находится минимальный элемент ' + minValue);
}
////////////////////////////////////////////////////////////////////////////////////

// Медіана у непарній кількості елементів масиву. Технічне  завдання
/*
Медіану легко отримати із масиву з непарним кількістю елементів. Для цього потрібно правильно порахувати індекс середнього елемента.
Віднімаємо з довжини масиву одиницю і ділимо на два і індекс знайдений.
*/
let usersByDay = [1, 2, 3, 4, 5];
console.log(usersByDay);
let median;

if (usersByDay.length % 2 !== 0) {
    let medianIndex = (usersByDay.length - 1) / 2;
    console.log(medianIndex);
    median = usersByDay[medianIndex];
    console.log(median)
}

// Медіана у парній кількості елементів масиву. Технічне  завдання
/*
Якщо кількість елементів парна, то медіана вважається як середнє значення від двох елементів: лівого і правого від середини. Ділимо довжину масиву на два і віднімаємо одиницю - лівий індекс знайдений. Ділимо довжину масиву на два - правий індекс знайдений.
Розрахунок медіани для парної кількості елементів в масиві проводимо у альтернативній гілці.
*/
let usersByDay = [1, 2, 3, 4, 5, 6];
console.log(usersByDay);
let median;

if (usersByDay.length % 2 !== 0) {
  let medianIndex = (usersByDay.length - 1) / 2;
  console.log(medianIndex);
  median = usersByDay[medianIndex];
  console.log(median);
} else {
  let leftIndex = usersByDay.length / 2 - 1;
  let rightIndex = usersByDay.length / 2;
  console.log(leftIndex, rightIndex);
  median = (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
  console.log(median)
  }

////////////////////////////////////////////////////////////////////////////////////
let expectedUsers = 1000;
let usersByDay = [817, 581, 1370, 752, 1247, 681, 1120, 915, 875, 1341, 757, 610, 812, 741, 1139, 812, 638, 877, 1242, 1159, 1372, 1170, 845, 1289, 515, 1247, 769, 1261, 2805, 1201];

// Рисуем график посещаемости
keks.plot(usersByDay, expectedUsers);

// Суммируем посещаемость
let totalUsers = 0;
for (let i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
}

// Рассчитываем среднее значение посещаемости
let averageUsers = totalUsers / usersByDay.length;
console.log('Средняя посещаемость: ' + averageUsers);

if (averageUsers > expectedUsers) {
  console.log('Посещаемость великолепна. Продолжай в том же духе!');
} else {
  console.log('Посещаемость так себе. Нужно поднапрячься!');
}

// Сортируем массив
for (let i = 0; i <= usersByDay.length - 2; i++) {
  let minValue = usersByDay[i];

  for (let j = i + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      let swap = usersByDay[i];
      usersByDay[i] = minValue;
      usersByDay[j] = swap;
    }
  }
}

// Рассчитываем медиану
let median;
if (usersByDay.length % 2 !== 0) {
  let medianIndex = (usersByDay.length - 1) / 2;
  median = usersByDay[medianIndex];
} else {
  let leftIndex = usersByDay.length / 2 - 1;
  let rightIndex = usersByDay.length / 2;
  median = (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
}

console.log('Медианная посещаемость: ' + median);
////////////////////////////////////////////////////////////////////////////////////

// Рекорди зі стрибків у довжину. Технічне завдання
/*
Я проводжу тренування і хочу зрозуміти, чи пройду кваліфікацію.
Протягом тренування я роблю кілька стрибків, і збираю довжини стрибків у масив attempts.
Програма повинна вибрати три кращих стрибка, а потім порахувати середнє значення цих трьох стрибків і записати його в змінну averageBest.
Кваліфікаційне значення зберігається в змінної qualificationDistance.
Якщо середнє від кращих трьох стрибків більше кваліфікаційного значення, то я пройшов кваліфікацію і змінна qualified повинна містити true. Якщо кваліфікація не пройдена, то в qualified має бути false.
*/
// Варіант 1
let qualificationDistance = 200;
let attempts = [120, 150, 160, 201, 203, 180, 202];
let qualified = false;
let averageBest = 0;

for (let i = 0; i <= attempts.length - 2; i++) {
      let minAttempts = attempts[i];
      
      for (let j = i + 1; j <= attempts.length -1; j++) {
        if (attempts[j] < minAttempts) {
         minAttempts = attempts[j];
         let swap = attempts[i];
         attempts[i] = minAttempts;
         attempts[j] = swap;
        }
      }
    } // так ми сортуємо масив у порядку зростання знаячень елементів

let countOfBest = attempts[attempts.length - 1] + attempts[attempts.length  - 2] + attempts[attempts.length  - 3]; // знаходимо суму трьох останніх елементів масиву

//averageBest  = (attempts[attempts.length - 1] + attempts[attempts.length  - 2] + attempts[attempts.length  - 3]) / 3; // альтернативний запис

averageBest = countOfBest / 3;

if (averageBest > qualificationDistance) {
     qualified = true;  
  } 

// Варіант 2
let qualificationDistance = 200;
let attempts = [120, 150, 160, 201, 203, 180, 202];
let qualified = false;
let averageBest = 0;

let sortAttempts = attempts.sort();
averageBest  = (sortAttempts[sortAttempts.length - 1] + sortAttempts[sortAttempts.length  - 2] + sortAttempts[sortAttempts.length  - 3]) / 3;

if (averageBest > qualificationDistance) {
     qualified = true;  
  } 

// Варіант 3
let qualificationDistance = 200;
let attempts = [120, 150, 160, 201, 203, 180, 202];
let qualified = false;
let averageBest = 0;

attempts.sort(function (a, b) { return b - a }); // сортування у зворотньому порядку
  
averageBest  = (attempts[0] + attempts[1] + attempts[2]) / 3;

if (averageBest > qualificationDistance) {
     qualified = true;  
  } 
////////////////////////////////////////////////////////////////////////////////////


// ФУНКЦІЇ
// Перетворюємо стандартний розрахунок на функцію для оптимізації коду
// Нижче  у нас є код програми, який вираховує знижко-милі у залежності від відстані,  яку ми вже пролетіли. Проте для того, щи вираховувати  кожен раз нову знижку у залежності від нового напрямку, нам потрібно дублювати код, перезначати перемінні і вписувати у них нові цифри, що є не дуже зручно
let percent = 0.25;
let distance = 4125;
if (distance > 10500) {
  percent = 0.35;
}
let miles = distance * percent;
console.log('За політ у Будапешт ' + miles + ' миль');

percent = 0.25;
distance = 11000;
if (distance > 10500) {
  percent = 0.35;
}
miles = distance * percent;
console.log('За політ у Відень ' + miles + ' миль');

// Функція - шматок коду, який можна написати один раз, а потім багаторазово використовувати. Функція не просто містить в собі значення, як перемінна, а виконує якусь дію і вирішує якесь завдання: підраховує, порівнює, шукає. Наприклад, наша функція буде обчислювати накопичені милі з перельоту.
let calculateMiles = function () {
  let percent = 0.25;
  let distance = 4125;

  if (distance > 10500) {
    percent = 0.35;
  }
  let miles = distance * percent;

  console.log('За політ у Будапешт ' + miles + ' миль');
  }

  // Для того, щоб постійно не змінювати знаяення перемінної постійно, ми використовуємо параметри функції. Параметри - значення, за допомогою яких можна налаштовувати функції. Так ми можемо дізнатися результат роботи функції для різних випадків.
  // Щоб функція працювала з параметрами, їх треба якось передати і дати їм назви. 
  // 1. Задаємо параметри. У момент оголошення функції, в круглих дужках, ми створюємо параметри. Тут все, як зі перемінними: спочатку задаємо параметрам імена, які описують, що за значення будуть в них записані. Якщо параметрів кілька, вони записуються через кому. let showTime = function (hours, minutes) {}
  // 2. Використовуємо параметри. Параметри працюють так само, як перемінні. Ми підставляємо їх замість фіксованих значень в операції всередині функції. При виконанні коду замість кожного параметра підставить його значення.
  // 3. Функція отримує значення параметрів. У момент виклику функції ми вказуємо в круглих дужках ті значення, які знаходяться в параметрах. Ми пишемо showTime (16, 20) і замість hours в тілі функції підставляється 16, а замість minutes число 20.
  // Ось таким чином ми оптимізовуємо код, який писали вище, за допомогою параметрів
  let calculateMiles = function (distance) {
    let percent = 0.25;
    if (distance > 10500) {
      percent = 0.35;
    }
    let miles = distance * percent;
    console.log('За політ отримаємо ' + miles + ' миль');
  };
  calculateMiles(4125);
  calculateMiles(11000); // щоб функція виконалась, її потрібно викликати
  
  // Щоб функція повернула значення, ми використовуємо оператор return. Після оператора вказуємо, що саме треба повернути. У нашому випадку значення перемінної miles. Коли програма доходить до рядка з return, функція віддає результат своєї роботи і виконання коду з тіла функції зупиняється, іншими словами відбувається вихід з функції.

// Кілька речей, які потрібно знати про return:
// - код, написаний на новому рядку після return, не виконується.
// - функція не може повернути відразу багато значень, вона повертає тільки один результат.
// - якщо всередині функції немає return або після return не вказано, яке значення потрібно повернути, функція поверне undefined, іншими словами, нічого.
let calculateMiles = function (distance) {
  let percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  let miles = Math.floor(distance * percent);
  return miles;
};

console.log('За політ у Будапешт ' + calculateMiles(4125) + ' миль');
console.log('За політ у Відень ' + calculateMiles(11000) + ' миль');